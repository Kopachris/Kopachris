#!/usr/bin/env python
# coding: utf8
from gluon import *
import bot_utils
import re

## Description stored in db.bot_modules
# returned by !help command
description = "regex substitutes the previous message"

## Prefix stored in db.bot_modules
## Each module should have its own prefix for bot_vars entries
prefix = "re_"

## Event type handled by this module
event_type = "PRIVMSG"

_cmd = ["s/"]

## Additional global vars go here

# a lot of websites block specific user-agent strings associated with bots
# use this to avoid that if your module retrieves webpages
#H_HTTP = {'User-Agent': 'Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11'}

def init(db):
    # called when module is uploaded
    pass


def remove(db):
    # called when module is disabled
    pass


def run(bot, event, db):
    mod_name = __name__.rsplit('.', 1)[1]
    this_mod = db(db.bot_modules.name == mod_name).select()
    prefix = this_mod.first().vars_pre
    m_items = prefix + "items"
    bot_nick = bot.nickname
    log = db.event_log
    
    m = event.message.split('/')
    
    if m[0] == 's' and (len(m) == 3 or len(m) == 4):
        reg = m[1]
        sub = m[2]
        all_m = db(((log.event_type == 'PRIVMSG') | (log.event_type == 'CTCP_ACTION')) & (log.event_target == event.target) & ~(log.event_source == bot_nick)).select(log.ALL, orderby=~log.id, limitby=(1,47))
        #prev_m = all_m.records[-2:-15:-1]
        for msg in all_m:
            #msg = old_m.event_log
            if len(m) == 4 and m[3] == 'g':
                new_m = re.sub(reg, sub, msg.event_message)
            else:
                new_m = re.sub(reg, sub, msg.event_message, 1)
            if new_m != msg.event_message:
                bot.bot_reply(event, '<{}> {}'.format(msg.event_source, new_m), False)
                return
